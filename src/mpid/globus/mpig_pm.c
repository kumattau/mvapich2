/*
 * Globus device code:          Copyright 2005 Northern Illinois University
 * Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
 * Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
 *
 * XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
 */

#include "mpidimpl.h"


/* FIXME: this list should be generated by configure based on a list of process management modules. */
extern mpig_pm_t mpig_pm_ws;
extern mpig_pm_t mpig_pm_gk;
extern mpig_pm_t mpig_pm_vmpi;

/* FIXME: the defintion of this array should be generated by configure based on a list of process management modules. */
MPIG_STATIC mpig_pm_t * const mpig_pm_table[] =
{
#if TRUE
    &mpig_pm_ws,
    &mpig_pm_gk,
#endif    
    &mpig_pm_vmpi,
    /* MPI-2-NOTE: &mpig_pm_singleton_vtable, */
    NULL
};

MPIG_STATIC const int mpig_pm_table_num_entries = sizeof(mpig_pm_table) / sizeof(mpig_pm_t *) - 1;
MPIG_STATIC mpig_pm_t * mpig_pm_my_object = NULL;
MPIG_STATIC mpig_pm_vtable_t * mpig_pm_my_vtable = NULL;


/*
 * mpig_pm_init()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_init
int mpig_pm_init(int * argc, char *** argv)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int n;
    int mrc;
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_init);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_init);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    /* MPI-2-FIXME: when we implement spawn, we will want to allow the application to spawn processes using any of the available
       PM modules.  as a result, it will be necessary to run the init() routine of all available PM modules, and not stop as soon
       when we find the one that is appropriate for managing the process group to which the current process group belongs.  see
       mpig_pm_finalize() for additional comments. */
    
    for (n = 0; n < mpig_pm_table_num_entries; n++)
    {
	bool_t my_pm;

	if (mpig_pm_table[n]->vtable != NULL)
	{
	    mrc = mpig_pm_table[n]->vtable->init(argc, argv, mpig_pm_table[n], &my_pm);
	    if (mrc) MPIU_ERR_ADD(mpi_errno, mrc);
	
	    if (my_pm)
	    {
		mpig_pm_my_object = mpig_pm_table[n];
		mpig_pm_my_vtable = mpig_pm_table[n]->vtable;
		break; /*for n */
	    }
	}
    }

    MPIU_ERR_CHKANDSTMT((mpig_pm_my_object == NULL), mpi_errno, MPI_ERR_OTHER, {;}, "**globus|pm_no_module");
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: mpi_errno=" MPIG_ERRNO_FMT, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_init);
    return mpi_errno;
}
/* mpig_pm_init() */


/*
 * mpig_pm_finalize()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_finalize
int mpig_pm_finalize(void)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_finalize);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_finalize);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    /* MPI-2-FIXME: when we implement spawn, we will want to allow the application to spawn processes using any of the available
       PM modules.  as a results, it will be necessary to run the finalize() routine of all available PM modules, and not just
       the one managing the process group to which the current process belongs.  see mpig_pm_init() for additional comments. */
    mpi_errno = mpig_pm_my_vtable->finalize(mpig_pm_my_object);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: mpi_errno=" MPIG_ERRNO_FMT, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_finalize);
    return mpi_errno;
}
/* mpig_pm_finalize() */


/*
 * mpig_pm_abort()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_abort
int mpig_pm_abort(int exit_code)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_abort);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_abort);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    if (mpig_pm_my_vtable && mpig_pm_my_vtable->abort)
    {
	mpi_errno = mpig_pm_my_vtable->abort(mpig_pm_my_object, exit_code);
    }
    else
    {
	abort();
    }
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: mpi_errno=" MPIG_ERRNO_FMT, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_abort);
    return mpi_errno;
}
/* mpig_pm_abort() */


/*
 * mpig_pm_exchange_business_cards()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_exchange_business_cards
int mpig_pm_exchange_business_cards(mpig_bc_t * const bc, mpig_bc_t ** const bcs_p)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_exchange_business_cards);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_exchange_business_cards);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering: bc=" MPIG_PTR_FMT, MPIG_PTR_CAST(bc)));

    mpi_errno = mpig_pm_my_vtable->exchange_business_cards(mpig_pm_my_object, bc, bcs_p);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM,
	"exiting: bcs=" MPIG_PTR_FMT ", mpi_errno=" MPIG_ERRNO_FMT, MPIG_PTR_CAST(*bcs_p), mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_exchange_business_cards);
    return mpi_errno;
}
/* mpig_pm_exchange_business_cards() */


/*
 * mpig_pm_free_business_cards()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_free_business_cards
int mpig_pm_free_business_cards(mpig_bc_t * const bcs)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_free_business_cards);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_free_business_cards);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering: bcs=" MPIG_PTR_FMT, MPIG_PTR_CAST(bcs)));

    mpi_errno = mpig_pm_my_vtable->free_business_cards(mpig_pm_my_object, bcs);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: mpi_errno=" MPIG_ERRNO_FMT, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_free_business_cards);
    return mpi_errno;
}
/* mpig_pm_free_business_cards() */


/*
 * mpig_pm_get_pg_size()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_get_pg_size
int mpig_pm_get_pg_size(int * const pg_size_p)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_get_pg_size);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_get_pg_size);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    mpi_errno = mpig_pm_my_vtable->get_pg_size(mpig_pm_my_object, pg_size_p);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: pg_size=%d, mpi_errno=" MPIG_ERRNO_FMT,
	(mpi_errno) ? -1 : *pg_size_p, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_get_pg_size);
    return mpi_errno;
}
/* mpig_pm_get_pg_size() */


/*
 * mpig_pm_get_pg_rank()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_get_pg_rank
int mpig_pm_get_pg_rank(int * const pg_rank_p)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_get_pg_rank);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_get_pg_rank);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    mpi_errno = mpig_pm_my_vtable->get_pg_rank(mpig_pm_my_object, pg_rank_p);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: pg_rank=%d, mpi_errno=" MPIG_ERRNO_FMT,
	(mpi_errno) ? -1 : *pg_rank_p, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_get_pg_rank);
    return mpi_errno;
}
/* mpig_pm_get_pg_rank() */


/*
 * mpig_pm_get_pg_id()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_get_pg_id
int mpig_pm_get_pg_id(const char ** const pg_id_p)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_get_pg_id);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_get_pg_id);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    mpi_errno = mpig_pm_my_vtable->get_pg_id(mpig_pm_my_object, pg_id_p);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: pg_id=%s, mpi_errno=" MPIG_ERRNO_FMT,
	(mpi_errno) ? "(null)" : *pg_id_p, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_get_pg_id);
    return mpi_errno;
}
/* mpig_pm_get_pg_id() */


/*
 * mpig_pm_get_app_num()
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_get_app_num
int mpig_pm_get_app_num(const mpig_bc_t * const bc, int * const app_num_p)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    int mpi_errno = MPI_SUCCESS;
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_get_app_num);

    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_get_app_num);
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "entering"));

    mpi_errno = mpig_pm_my_vtable->get_app_num(mpig_pm_my_object, bc, app_num_p);
    
    /* fn_return: */
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_FUNC | MPIG_DEBUG_LEVEL_PM, "exiting: app_num=%d, mpi_errno=" MPIG_ERRNO_FMT,
	(mpi_errno) ? -1 : *app_num_p, mpi_errno));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_get_app_num);
    return mpi_errno;
}
/* mpig_pm_get_app_num() */


/*
 * <float *> mpig_pm_vtable_last_entry(...)
 *
 * this routine serves as the last function in the VC function table.  its purpose is to help detect when a communication
 * module's VC table has not be updated when a function be added or removed from the table.  it is not fool proof as it requires
 * the type signature not to match, but there should be few (if any) routines in the VC table that have no arguments and return
 * no values.
 */
#undef FUNCNAME
#define FUNCNAME mpig_pm_vtable_last_entry
float * mpig_pm_vtable_last_entry(double foo, int bar, const float * baz, short bif)
{
    const char fcname[] = MPIG_QUOTE(FUNCNAME);
    MPIG_STATE_DECL(MPID_STATE_mpig_pm_vtable_last_entry);

    MPIG_UNUSED_ARG(foo);
    MPIG_UNUSED_ARG(bar);
    MPIG_UNUSED_ARG(baz);
    MPIG_UNUSED_ARG(bif);
    MPIG_UNUSED_VAR(fcname);

    MPIG_FUNC_ENTER(MPID_STATE_mpig_pm_vtable_last_entry);
    
    MPIG_DEBUG_PRINTF((MPIG_DEBUG_LEVEL_ERROR, "FATAL ERROR: mpig_pm_vtable_last_entry called.  aborting program"));
    MPIG_FUNC_EXIT(MPID_STATE_mpig_pm_vtable_last_entry);
    MPID_Abort(NULL, MPI_SUCCESS, 13, "FATAL ERROR: mpig_pm_vtable_last_entry called.  Aborting Program.");
    return NULL;
}
/* mpig_pm_vtable_last_entry() */
