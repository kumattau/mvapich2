#! /usr/bin/perl
# -*- Mode: perl; -*-
#
# Set to zero if you want to see the ar/ranlib steps
$no_lib_steps = 1;

# This is a simple script to clean up the output from make by removing
# various compilation options (such as the list of -I directories), 
# -W options for gcc, and successful compiles.
$last_line = "";

#
# We accumulate lines into "last_line" until we believe that we have reached 
# a new command.  This allows us to output the command and any 
# subsequent warning messages, e.g., the compilation command followed
# by all messages.  A blank line or a known command are among the
# input that clears the "last_line" field.
while (<>) {
    # skip lines that start with for and are continued.
    if (/^\s*for dir in .*\\$/) {
	while (<>) {
	    if (! /\\$/) { last; }
	}
	if (/\sdone\s*$/) { next; }
    }
    # skip lines that start with if and are continued
    if (/^\s*if \[ ! -d lib.*\\$/) {
	while (<>) {
	    if (! /\\$/) { last; }
	}
	if (/^\s*fi\s*$/) { next; }
    }
    # skip lines that start with "for file in .tmp"
    if (/^\s*for file in \.tmp/) {
	while (/\\$/) {
	    $_ = <>;
	}
	next;
    }
    if (/^\s*if \[ \"/) {
	while (/\\$/) {
	    $_ = <>;
	}
	if (/^\s*fi\s*$/) { next; }
    }
    # skip lines that make the shared libraries
    if (/^\s*if \[ \"none\".* mpich.la/) {
	next;
    }
    # skip lines that mkdir .tmp and are continued
    if (/^\s*mkdir\s+\.tmp/ || /^\s*\(cd\s+\.tmp/) {
	$last_line = "";
	while (/\\$/) {
	    $_ = <>;
	}
	next;
    }
    # skip lines that have conditional mkdirs
    if (/\s*if\s.*then mkdir\s.*fi/) {
	next;
    }

    # Clean up compiler output
    if (/^[agi]?cc\s/ || /^pgcc\s/) {
	while (/\\$/) {
	    s/\\$//;
	    s/[\r\n]*//;
	    $_ .= <>;
	}
	s/-I[^\s]*\s*//g;
	s/-DHAVE_CONFIG_H\s*//g;
    }
    if (/^[agi]?c\+\+\s/ || /^CC\s/ || /^pgCC\s/) {
	s/-I[^\s]*\s*//g;
	s/-DHAVE_CONFIG_H\s*//g;
    }
    if (/^[-A-Za-z0-9\.\/]*mpicc\s/) {
	s/[-A-Za-z0-9\.\/]*mpicc\s/mpicc /;
	s/-I[^\s]*\s*//g;
	s/-W[^\s]*\s*//g;
	s/-ansi\s*//g;
	s/-DHAVE_CONFIG_H\s*//g;
    }
    if (/^gcc /) {
	s/-W[^\s]*\s*//g;
	s/-ansi\s*//g;
    }
    
    if (/^\s*make /) { 
	$last_line = "";
	next; 
    }
    if (/^\s*gnumake /) { 
	$last_line = "";
	next; 
    }

    if (/Nothing to be done for /) {
	$last_line = "";
	next;
    }
    if (/cleaning directory/) {
	$last_line = "";
	next;
    }
    if (/compiling ROMIO in directory/ || /building profiling interface/) {
	$last_line = "";
	next;
    }
    # Skip rm and mv lines
    if (/^\s*rm /) { next; }
    if (/\s*mv /) { next; }

    if (/WARNING 84.*not used for resolving any symbol/) { next; }
    if (/Info: File not optimized/) { next; }

    if ($no_lib_steps) {
	if (/^\s*ar\s/ || /^\s*ranlib\s/ || /^\s*true\s/) {
	    $last_line = ""; 
	    next; }
    }
    else {
	if (/^\s*ar\s/) { $_ = "...ar step\n"; $last_line = ""; }
    }

    # Skip the time adjust step
    # The sleep line is often added to handle problems in 
    # file-system synchronization
    if (/^\s*perl -e/ || /^\s*sleep\s+\d*/) { next; }

    if ($last_line =~ /[^\s]/) { 
	# Decide if we want to print this, based on the current line.
	if ($last_line =~ /^[agi]?cc\s/ || $last_line =~ /^mpicc\s/ ||
	    $last_line =~ /^pgcc\s/) {
	    # The icc compiler (and perhaps others) echo the file name (!)
	    # Try to capture that and ignore that line (reading another
	    # line as necessary)
	    $last_line =~ /^(.*\s+)([^\s]+)\s*$/;
	    $srcname = $2;
	    # Need to quote any metacharacters in srcname.  We
	    # use \Q<variable>\E
	    #print " src name = $srcname, other = $1\n";
	    # skip line ONLY if all that is on it is the file name, 
	    # to allow "filename: message"
	    if (/^\s*\Q$srcname\E\s*[:]*\s*$/) { next; }

	    if (! (/^[aig]?cc\s/) && ! (/^mpicc\s/) && ! (/^\.\.\.ar/) 
		&& !( /\s*if\s*\[.*then/) && ! (/^\s*mkdir \.tmp/)) { 
		# Add a new line to help the compile line stand out.
		print "\n";
		print $last_line; 
	    }
	}
	else {
	    print $last_line;
	}
    }
    # If we reach this point, we're ready to reset the last_line field
    $last_line = $_;
}
print $last_line;
